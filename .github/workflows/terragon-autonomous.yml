name: Terragon Autonomous SDLC

on:
  push:
    branches: [ main ]
  schedule:
    # Hourly value discovery and execution
    - cron: '15 * * * *'  # Run at :15 past every hour
  workflow_dispatch:
    inputs:
      force_execution:
        description: 'Force execution of next best value item'
        required: false
        default: 'false'
        type: boolean

env:
  PYTHON_VERSION: "3.11"
  POETRY_VERSION: "1.7.1"

jobs:
  autonomous-value-discovery:
    runs-on: ubuntu-latest
    outputs:
      has_work: ${{ steps.discover.outputs.has_work }}
      next_item: ${{ steps.discover.outputs.next_item }}
      
    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Full history for analysis
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: ${{ env.POETRY_VERSION }}
        
    - name: Install dependencies
      run: poetry install --with dev
      
    - name: Run value discovery engine
      id: discover
      run: |
        echo "ðŸ” Running Terragon value discovery..."
        python .terragon/backlog-engine.py > discovery-output.json
        
        # Check if we found work to do
        if [ -s discovery-output.json ]; then
          echo "has_work=true" >> $GITHUB_OUTPUT
          echo "next_item=$(cat discovery-output.json | jq -c .)" >> $GITHUB_OUTPUT
          echo "âœ… Found high-value work item"
        else
          echo "has_work=false" >> $GITHUB_OUTPUT
          echo "â„¹ï¸ No items meet execution criteria"
        fi
        
    - name: Generate updated backlog
      run: |
        python .terragon/generate-backlog-md.py
        
    - name: Upload discovery artifacts
      uses: actions/upload-artifact@v3
      with:
        name: value-discovery-results
        path: |
          .terragon/current-backlog.json
          .terragon/value-metrics.json
          BACKLOG.md
          discovery-output.json
          
  autonomous-execution:
    runs-on: ubuntu-latest
    needs: autonomous-value-discovery
    if: needs.autonomous-value-discovery.outputs.has_work == 'true' || github.event.inputs.force_execution == 'true'
    
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Set up Python  
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install Poetry
      uses: snok/install-poetry@v1
      with:
        version: ${{ env.POETRY_VERSION }}
        
    - name: Install dependencies
      run: poetry install --with dev
      
    - name: Parse next work item
      id: parse
      run: |
        NEXT_ITEM='${{ needs.autonomous-value-discovery.outputs.next_item }}'
        echo "Next item: $NEXT_ITEM"
        
        # Extract key details
        ITEM_ID=$(echo "$NEXT_ITEM" | jq -r '.id // "unknown"')
        ITEM_TITLE=$(echo "$NEXT_ITEM" | jq -r '.title // "Unknown work item"')
        ITEM_CATEGORY=$(echo "$NEXT_ITEM" | jq -r '.category // "unknown"')
        BRANCH_NAME="auto-value/${ITEM_ID}-$(date +%s)"
        
        echo "item_id=$ITEM_ID" >> $GITHUB_OUTPUT
        echo "item_title=$ITEM_TITLE" >> $GITHUB_OUTPUT
        echo "item_category=$ITEM_CATEGORY" >> $GITHUB_OUTPUT
        echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
        
    - name: Create feature branch
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "Terragon Autonomous SDLC"
        git checkout -b ${{ steps.parse.outputs.branch_name }}
        
    - name: Execute autonomous work item
      id: execute
      run: |
        echo "ðŸ¤– Executing: ${{ steps.parse.outputs.item_title }}"
        
        # Execute based on category
        case "${{ steps.parse.outputs.item_category }}" in
          "dependency_update")
            echo "ðŸ“¦ Updating dependencies..."
            poetry update
            ;;
          "technical_debt")
            echo "ðŸ”§ Addressing technical debt..."
            # Run code quality improvements
            poetry run ruff --fix . || true
            poetry run black . || true
            poetry run isort . || true
            ;;
          "security")
            echo "ðŸ”’ Addressing security issues..."
            # Apply security fixes (would need specific logic per issue)
            poetry run bandit -r privacy_finetuner/ --fix || true
            ;;
          "documentation")
            echo "ðŸ“š Improving documentation..."
            # Auto-generate missing docstrings where possible
            # This is a placeholder - real implementation would be more sophisticated
            ;;
          *)
            echo "âš ï¸ Generic task execution"
            ;;
        esac
        
        # Check if changes were made
        if git diff --quiet; then
          echo "executed=false" >> $GITHUB_OUTPUT
          echo "No changes made during execution"
        else
          echo "executed=true" >> $GITHUB_OUTPUT
          echo "Changes detected - work completed"
        fi
        
    - name: Run validation tests
      if: steps.execute.outputs.executed == 'true'
      run: |
        echo "ðŸ§ª Running validation tests..."
        
        # Linting
        poetry run ruff check . || exit 1
        poetry run black --check . || exit 1
        poetry run isort --check-only . || exit 1
        
        # Type checking  
        poetry run mypy privacy_finetuner/ || exit 1
        
        # Unit tests
        poetry run pytest tests/unit/ -v --maxfail=5 || exit 1
        
        # Security check
        poetry run bandit -r privacy_finetuner/ || exit 1
        
        echo "âœ… All validation tests passed"
        
    - name: Commit changes
      if: steps.execute.outputs.executed == 'true'
      run: |
        git add -A
        git commit -m "ðŸ¤– AUTO-VALUE: ${{ steps.parse.outputs.item_title }}

        Category: ${{ steps.parse.outputs.item_category }}
        Item ID: ${{ steps.parse.outputs.item_id }}
        
        This change was autonomously identified and executed by the Terragon Labs 
        Autonomous SDLC system based on continuous value discovery and WSJF+ICE+TechDebt scoring.
        
        ðŸŽ¯ Generated with [Claude Code](https://claude.ai/code)
        
        Co-Authored-By: Claude <noreply@anthropic.com>"
        
    - name: Create pull request
      if: steps.execute.outputs.executed == 'true'
      env:
        GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        # Get work item details for PR body
        NEXT_ITEM='${{ needs.autonomous-value-discovery.outputs.next_item }}'
        DESCRIPTION=$(echo "$NEXT_ITEM" | jq -r '.description // "Autonomous SDLC improvement"')
        COMPOSITE_SCORE=$(echo "$NEXT_ITEM" | jq -r '.composite_score // 0')
        
        # Create PR
        gh pr create \
          --title "ðŸ¤– [AUTO-VALUE] ${{ steps.parse.outputs.item_title }}" \
          --body "$(cat <<'EOF'
## ðŸŽ¯ Autonomous Value Discovery

**Item ID**: ${{ steps.parse.outputs.item_id }}  
**Category**: ${{ steps.parse.outputs.item_category }}  
**Composite Score**: ${COMPOSITE_SCORE}

### Description
${DESCRIPTION}

### Autonomous Execution Summary
This pull request was automatically created by the Terragon Labs Autonomous SDLC system after:

1. **Discovery**: Identified this item through continuous analysis of:
   - Git history and code comments
   - Static analysis results  
   - Code complexity metrics
   - External vulnerability databases

2. **Scoring**: Calculated composite value score using:
   - **WSJF** (Weighted Shortest Job First)
   - **ICE** (Impact Ã— Confidence Ã— Ease)
   - **Technical Debt** cost analysis
   - **Security/Compliance** priority boosts

3. **Execution**: Autonomously implemented the solution with:
   - âœ… All linting checks passed
   - âœ… Type checking passed
   - âœ… Unit tests passed
   - âœ… Security scans passed

### Value Metrics
- **Business Impact**: High priority based on scoring algorithm
- **Risk Level**: Low (automated validation passed)
- **Implementation Confidence**: High (comprehensive testing)

### Review Instructions
This PR follows all repository standards and has passed automated validation. 
Please review for:
- Business logic correctness
- Integration impact
- Any edge cases not covered by tests

---

**ðŸ¤– Generated by Terragon Labs Autonomous SDLC v1.0**

ðŸŽ¯ **Generated with [Claude Code](https://claude.ai/code)**

**Co-Authored-By: Claude <noreply@anthropic.com>**
EOF
)" \
          --label "autonomous" \
          --label "value-driven" \
          --label "${{ steps.parse.outputs.item_category }}" \
          --assignee "@me"
          
    - name: Update metrics with execution results
      if: always()  # Run regardless of success/failure
      run: |
        # Update execution metrics
        EXECUTION_SUCCESS=${{ steps.execute.outputs.executed == 'true' && 'true' || 'false' }}
        
        python -c "
import json
from datetime import datetime

# Load current metrics
try:
    with open('.terragon/value-metrics.json', 'r') as f:
        metrics = json.load(f)
except:
    metrics = {'execution_history': [], 'continuous_metrics': {}}

# Add execution record
execution_record = {
    'timestamp': datetime.now().isoformat() + 'Z',
    'itemId': '${{ steps.parse.outputs.item_id }}',
    'title': '${{ steps.parse.outputs.item_title }}',
    'category': '${{ steps.parse.outputs.item_category }}',
    'status': 'completed' if $EXECUTION_SUCCESS else 'failed',
    'automated': True,
    'branch': '${{ steps.parse.outputs.branch_name }}',
    'validation_passed': $EXECUTION_SUCCESS
}

metrics['execution_history'].append(execution_record)

# Update continuous metrics
metrics['continuous_metrics']['last_execution'] = datetime.now().isoformat() + 'Z'
metrics['continuous_metrics']['total_autonomous_executions'] = len([r for r in metrics['execution_history'] if r.get('automated')])
metrics['continuous_metrics']['success_rate'] = len([r for r in metrics['execution_history'] if r.get('status') == 'completed']) / max(len(metrics['execution_history']), 1)

# Save updated metrics
with open('.terragon/value-metrics.json', 'w') as f:
    json.dump(metrics, f, indent=2)
    
print('âœ… Updated execution metrics')
        "
        
    - name: Commit backlog updates
      if: always()
      run: |
        git config --local user.email "action@github.com" 
        git config --local user.name "Terragon Autonomous SDLC"
        git checkout main
        git pull origin main
        
        # Update backlog files  
        python .terragon/generate-backlog-md.py
        
        git add .terragon/value-metrics.json BACKLOG.md
        git diff --staged --quiet || git commit -m "ðŸ¤– Update autonomous execution metrics

        Updated after autonomous execution of: ${{ steps.parse.outputs.item_title }}
        
        ðŸŽ¯ Generated with [Claude Code](https://claude.ai/code)
        
        Co-Authored-By: Claude <noreply@anthropic.com>"
        git push origin main || true